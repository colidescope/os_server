# geom/protocol.py
from __future__ import annotations

from typing import Any, Dict, List, Protocol, Tuple, runtime_checkable

Interval = Tuple[float, float]

# ----------------------------
# Core immutable geometry types
# ----------------------------

@runtime_checkable
class GPoint(Protocol):
    x: float
    y: float
    z: float

    def translated(self, v: GVector) -> GPoint: ...
    def distance_to(self, other: GPoint) -> float: ...


@runtime_checkable
class GVector(Protocol):
    x: float
    y: float
    z: float

    def length(self) -> float: ...
    def unitized(self) -> GVector: ...
    def scaled(self, s: float) -> GVector: ...
    def negated(self) -> GVector: ...


@runtime_checkable
class GPlane(Protocol):
    def z_axis(self) -> GVector: ...


@runtime_checkable
class GLine(Protocol):
    def from_pt(self) -> GPoint: ...
    def to_pt(self) -> GPoint: ...
    def point_at(self, t: float) -> GPoint: ...

    def closest_parameter(self, pt: GPoint) -> float: ...

    def direction(self) -> GVector: ...
    def translated(self, v: GVector) -> GLine: ...


@runtime_checkable
class GCurve(Protocol):
    def duplicate(self) -> GCurve: ...
    def translated(self, v: GVector) -> GCurve: ...

    def to_points(self) -> List[GPoint]: ...

    # returns: "inside" | "outside" | "boundary"
    def contains(self, pt: GPoint, plane: GPlane) -> str: ...


@runtime_checkable
class GCircle(Protocol):
    def get_curve(self) -> GCurve: ...


@runtime_checkable
class GSolid(Protocol):
    def volume(self) -> float: ...
    def centroid(self) -> GPoint: ...

    # backend-defined bbox object; you only read what you need
    def bounding_box(self, plane: GPlane) -> Any: ...

    def translated(self, v: GVector) -> GSolid: ...


# ----------------------------
# Backend interface
# ----------------------------

class GeomBackend(Protocol):
    # constructors
    def point(self, x: float, y: float, z: float) -> GPoint: ...
    def vector(self, x: float, y: float, z: float) -> GVector: ...
    def plane(self, origin: GPoint, normal: GVector) -> GPlane: ...

    def line(self, a: GPoint, b: GPoint) -> GLine: ...
    def circle(self, plane: GPlane, center: GPoint, r: float) -> GCircle: ...
    def solid(self, solid: Any) -> GSolid: ...

    # surface ops (backend decides what "surface" is: Face, Surface, etc.)
    def surface_plane(self, srf: Any) -> GPlane: ...
    def surface_boundary(self, srf: Any) -> GCurve: ...
    def surface_boundary_points(self, srf: Any) -> List[GPoint]: ...
    def normalize_vector_pair(self, v1: GVector, v2: GVector) -> Tuple[GVector, GVector]: ...

    # intersections
    def plane_plane_intersection(self, p1: GPlane, p2: GPlane) -> GLine: ...
    def line_line_params(self, l1: GLine, l2: GLine) -> Tuple[bool, float, float]: ...
    def curve_line_intersection(self, crv: GCurve, ln: GLine) -> List[float]: ...

    # solid ops
    def extrusion(self, profile: GCurve, dir: GVector, amount: float) -> GSolid: ...
    def boolean_difference(self, a: GSolid, b: GSolid) -> GSolid: ...
    def boolean_union(self, solids: List[GSolid]) -> GSolid: ...
